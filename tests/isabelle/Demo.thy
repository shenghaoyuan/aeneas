(** THIS FILE WAS AUTOMATICALLY GENERATED BY AENEAS *)
(** [demo] *)

theory Demo
  imports
    Aeneas.Primitives
    begin
\m
(* [core::num::{u32}::wrapping_add]:
   Source: '/rustc/library/core/src/num/uint_macros.rs', lines 2037:8-2037:58
   Name pattern: [core::num::{u32}::wrapping_add] *)
axiomatization core_num_U32_wrapping_add :: "u32 ⇒ u32 ⇒ result u32"

(* [core::num::{u32}::wrapping_sub]:
   Source: '/rustc/library/core/src/num/uint_macros.rs', lines 2074:8-2074:58
   Name pattern: [core::num::{u32}::wrapping_sub] *)
axiomatization core_num_U32_wrapping_sub :: "u32 ⇒ u32 ⇒ result u32"

(* [demo::choose]:
   Source: 'tests/src/demo.rs', lines 8:0-14:1 *)
definition choose
  ('t) (b : bool) (x : 't) (y : 't) : result ('t × ('t ⇒ ('t × 't))) where
  if b
  then let back = fun (ret : 't) => (ret, y) in Ok (x, back)
  else let back = fun (ret : 't) => (x, ret) in Ok (y, back)

(* [demo::mul2_add1]:
   Source: 'tests/src/demo.rs', lines 16:0-18:1 *)
definition mul2_add1 (x : u32) : result u32 where
  let i = u32_add x x in u32_add i 1 :: u32

(* [demo::use_mul2_add1]:
   Source: 'tests/src/demo.rs', lines 20:0-22:1 *)
definition use_mul2_add1 (x : u32) (y : u32) : result u32 where
  let i = mul2_add1 x in u32_add i y

(* [demo::incr]:
   Source: 'tests/src/demo.rs', lines 24:0-26:1 *)
definition incr (x : u32) : result u32 where
  u32_add x 1 :: u32

(* [demo::use_incr]:
   Source: 'tests/src/demo.rs', lines 28:0-33:1 *)
definition use_incr : result unit where
  let x = incr 0 :: u32 in let x1 = incr x in let _ = incr x1 in Ok ()
(* [demo::CList]
   Source: 'tests/src/demo.rs', lines 37:0-40:1 *)
datatype CList_t (''t') =
| CList_CCons 't of  CList_t 't ⇒ CList_t 't
| CList_CNil CList_t 't
where
  
  (* [demo::list_nth]:
     Source: 'tests/src/demo.rs', lines 42:0-55:1 *)
  fun list_nth ('t) (l : CList_t 't) (i : u32) : result 't where
    case l of
    | CList_CCons x tl =>
      if i = 0 :: u32
      then Ok x
      else (let i1 = u32_sub i 1 :: u32 in list_nth tl i1)
    | CList_CNil => Fail Failure
  
  where
    
    (* [demo::list_nth1]: loop 0:
       Source: 'tests/src/demo.rs', lines 58:4-66:1 *)
    fun list_nth1_loop ('t) (l : CList_t 't) (i : u32) : result 't where
      case l of
      | CList_CCons x tl =>
        if i = 0 :: u32
        then Ok x
        else (let i1 = u32_sub i 1 :: u32 in list_nth1_loop tl i1)
      | CList_CNil => Fail Failure
    
    (* [demo::list_nth1]:
       Source: 'tests/src/demo.rs', lines 57:0-66:1 *)
    definition list_nth1 ('t) (l : CList_t 't) (i : u32) : result 't where
      list_nth1_loop l i
    
    where
      
      (* [demo::list_nth_mut]:
         Source: 'tests/src/demo.rs', lines 68:0-81:1 *)
      fun list_nth_mut
        ('t) (l : CList_t 't) (i : u32) :
        result ('t × ('t ⇒ CList_t 't))
        where
        case l of
        | CList_CCons x tl =>
          if i = 0 :: u32
          then let back = fun (ret : 't) => CList_CCons ret tl in Ok (x, back)
          else (
            let i1 = u32_sub i 1 :: u32 in
            let (x1, list_nth_mut_back) = list_nth_mut tl i1 in
            let back =
              fun (ret : 't) =>
                let tl1 = list_nth_mut_back ret in CList_CCons x tl1
            in
            Ok (x1, back))
        | CList_CNil => Fail Failure
      
      where
        
        (* [demo::i32_id]:
           Source: 'tests/src/demo.rs', lines 83:0-89:1 *)
        fun i32_id (i : i32) : result i32 where
          if i = 0 :: i32
          then Ok 0 :: i32
          else (
            let i1 = i32_sub i 1 :: i32 in
            let i2 = i32_id i1 in
            i32_add i2 1 :: i32)
        
        where
          
          (* [demo::list_tail]:
             Source: 'tests/src/demo.rs', lines 91:0-96:1 *)
          fun list_tail
            ('t) (l : CList_t 't) :
            result ((CList_t 't) × (CList_t 't ⇒ CList_t 't))
            where
            case l of
            | CList_CCons t tl =>
              let (c, list_tail_back) = list_tail tl in
              let back =
                fun (ret : CList_t 't) =>
                  let tl1 = list_tail_back ret in CList_CCons t tl1
              in
              Ok (c, back)
            | CList_CNil => Ok (CList_CNil, fun (ret : CList_t 't) => ret)
          
          (* Trait declaration: [demo::Counter]
             Source: 'tests/src/demo.rs', lines 100:0-102:1 *)
          record Counter_t (''self') =
            incr :: 'self ⇒ result (usize × 'self)
          
          (* [demo::{demo::Counter for usize}::incr]:
             Source: 'tests/src/demo.rs', lines 105:4-109:5 *)
          definition counterUsize_incr
            (self : usize) : result (usize × usize) where
            let self1 = usize_add self 1 :: usize in Ok (self, self1)
          
          (* Trait implementation: [demo::{demo::Counter for usize}]
             Source: 'tests/src/demo.rs', lines 104:0-110:1 *)
          definition counterUsize :: Counter_t usize where "counterUsize = (|
            incr = counterUsize_incr
          |)"
          
          (* [demo::use_counter]:
             Source: 'tests/src/demo.rs', lines 112:0-114:1 *)
          definition use_counter
            ('t) ('counterInst : Counter_t 't') (cnt : 't) :
            result (usize × 't)
            where
            counterInst.incr cnt
          
          (* [demo::mod_add]:
             Source: 'tests/src/demo.rs', lines 117:0-125:1 *)
          definition mod_add (a : u32) (b : u32) : result u32 where
            let _ = massert (u32_lt a 3329 :: u32) in
            let _ = massert (u32_lt b 3329 :: u32) in
            let sum = u32_add a b in
            let res = core_num_U32_wrapping_sub sum 3329 :: u32 in
            let mask = u32_shr res 16 :: i32 in
            let q = return(u32_and 3329 :: u32 mask) in
            core_num_U32_wrapping_add res q
          
end
