(** THIS FILE WAS AUTOMATICALLY GENERATED BY AENEAS *)
(** [hashmap]: function definitions *)

theory Hashmap.Funs
  imports
    Aeneas.Primitives
    Hashmap.Types
    Hashmap.FunsExternal
    begin
\m
(* [hashmap::hash_key]:
   Source: 'tests/src/hashmap.rs', lines 36:0-41:1 *)
definition hash_key (k : usize) : result usize where
  Ok k

(* [hashmap::{core::clone::Clone for hashmap::Fraction}::clone]:
   Source: 'tests/src/hashmap.rs', lines 43:9-43:14 *)
definition clonehashmapFraction_clone
  (self : Fraction_t) : result Fraction_t where
  Ok self

(* [hashmap::{core::clone::Clone for hashmap::Fraction}::clone_from]:
   Source: 'tests/src/hashmap.rs', lines 43:9-43:14 *)
definition clonehashmapFraction_clone_from
  (self : Fraction_t) (source : Fraction_t) : result Fraction_t where
  clonehashmapFraction_clone source

(* Trait implementation: [hashmap::{core::clone::Clone for hashmap::Fraction}]
   Source: 'tests/src/hashmap.rs', lines 43:9-43:14 *)
definition core_clone_ClonehashmapFraction :: core_clone_Clone Fraction_t
  where "core_clone_ClonehashmapFraction = (|
  clone = clonehashmapFraction_clone
  clone_from = clonehashmapFraction_clone_from
|)"

(* Trait implementation: [hashmap::{core::marker::Copy for hashmap::Fraction}]
   Source: 'tests/src/hashmap.rs', lines 43:16-43:20 *)
definition core_marker_CopyhashmapFraction :: core_marker_Copy Fraction_t
  where "core_marker_CopyhashmapFraction = (|
  cloneInst = core_clone_ClonehashmapFraction
|)"

where
  
  (* [hashmap::{hashmap::HashMap<T>}::allocate_slots]: loop 0:
     Source: 'tests/src/hashmap.rs', lines 68:8-71:9 *)
  fun hashMap_allocate_slots_loop
    ('t) (slots : alloc_vec_Vec (AList_t 't)) (n : usize) :
    result (alloc_vec_Vec (AList_t 't))
    where
    if usize_gt n 0 :: usize
    then (
      let slots1 = alloc_vec_Vec_push slots AList_Nil in
      let n1 = usize_sub n 1 :: usize in
      hashMap_allocate_slots_loop slots1 n1)
    else Ok slots
  
  (* [hashmap::{hashmap::HashMap<T>}::allocate_slots]:
     Source: 'tests/src/hashmap.rs', lines 67:4-73:5 *)
  definition hashMap_allocate_slots
    ('t) (slots : alloc_vec_Vec (AList_t 't)) (n : usize) :
    result (alloc_vec_Vec (AList_t 't))
    where
    hashMap_allocate_slots_loop slots n
  
  (* [hashmap::{hashmap::HashMap<T>}::new_with_capacity]:
     Source: 'tests/src/hashmap.rs', lines 76:4-87:5 *)
  definition hashMap_new_with_capacity
    (''t') (capacity : usize) (max_load_factor : Fraction_t) :
    result (HashMap_t 't)
    where
    let slots =
      hashMap_allocate_slots (alloc_vec_Vec_new (AList_t 't)) capacity
    in
    let i = usize_mul capacity dividend max_load_factor in
    let i1 = usize_div i divisor max_load_factor in
    Ok
      (|
        num_entries = 0 :: usize,
        max_load_factor,
        max_load = i1,
        saturated = False,
        slots
      |)
  
  (* [hashmap::{hashmap::HashMap<T>}::new]:
     Source: 'tests/src/hashmap.rs', lines 89:4-98:5 *)
  definition hashMap_new (''t') : result (HashMap_t 't) where
    hashMap_new_with_capacity 't 32 :: usize
      (| dividend = 4 :: usize, divisor = 5 :: usize |)
  
  where
    
    (* [hashmap::{hashmap::HashMap<T>}::clear]: loop 0:
       Source: 'tests/src/hashmap.rs', lines 104:8-107:9 *)
    fun hashMap_clear_loop
      ('t) (slots : alloc_vec_Vec (AList_t 't)) (i : usize) :
      result (alloc_vec_Vec (AList_t 't))
      where
      let i1 = alloc_vec_Vec_len slots in
      if usize_lt i i1
      then (
        let (_, index_mut_back) =
          alloc_vec_Vec_index_mut (core_slice_index_SliceIndexUsizeSliceInst
            (AList_t 't)) slots i
        in
        let i2 = usize_add i 1 :: usize in
        let slots1 = index_mut_back AList_Nil in
        hashMap_clear_loop slots1 i2)
      else Ok slots
    
    (* [hashmap::{hashmap::HashMap<T>}::clear]:
       Source: 'tests/src/hashmap.rs', lines 100:4-108:5 *)
    definition hashMap_clear
      ('t) (self : HashMap_t 't) : result (HashMap_t 't) where
      let slots = hashMap_clear_loop slots self 0 :: usize in
      Ok (| self with num_entries := 0 :: usize, slots |)
    
    (* [hashmap::{hashmap::HashMap<T>}::len]:
       Source: 'tests/src/hashmap.rs', lines 110:4-112:5 *)
    definition hashMap_len ('t) (self : HashMap_t 't) : result usize where
      Ok num_entries self
    
    where
      
      (* [hashmap::{hashmap::HashMap<T>}::insert_in_list]: loop 0:
         Source: 'tests/src/hashmap.rs', lines 1:0-133:9 *)
      fun hashMap_insert_in_list_loop
        ('t) (key : usize) (value1 : 't) (ls : AList_t 't) :
        result (bool × (AList_t 't))
        where
        case ls of
        | AList_Cons ckey cvalue tl =>
          if ckey = key
          then Ok (False, AList_Cons ckey value1 tl)
          else (
            let (b, tl1) = hashMap_insert_in_list_loop key value1 tl in
            Ok (b, AList_Cons ckey cvalue tl1))
        | AList_Nil => Ok (True, AList_Cons key value1 AList_Nil)
      
      (* [hashmap::{hashmap::HashMap<T>}::insert_in_list]:
         Source: 'tests/src/hashmap.rs', lines 117:4-134:5 *)
      definition hashMap_insert_in_list
        ('t) (key : usize) (value1 : 't) (ls : AList_t 't) :
        result (bool × (AList_t 't))
        where
        hashMap_insert_in_list_loop key value1 ls
      
      (* [hashmap::{hashmap::HashMap<T>}::insert_no_resize]:
         Source: 'tests/src/hashmap.rs', lines 137:4-145:5 *)
      definition hashMap_insert_no_resize
        ('t) (self : HashMap_t 't) (key : usize) (value1 : 't) :
        result (HashMap_t 't)
        where
        let hash = hash_key key in
        let i = alloc_vec_Vec_len slots self in
        let hash_mod = usize_rem hash i in
        let (a, index_mut_back) =
          alloc_vec_Vec_index_mut (core_slice_index_SliceIndexUsizeSliceInst
            (AList_t 't)) slots self hash_mod
        in
        let (inserted, a1) = hashMap_insert_in_list key value1 a in
        if inserted
        then (
          let i1 = usize_add num_entries self 1 :: usize in
          let v = index_mut_back a1 in
          Ok (| self with num_entries := i1, slots := v |))
        else let v = index_mut_back a1 in Ok (| self with slots := v |)
      
      where
        
        (* [hashmap::{hashmap::HashMap<T>}::move_elements_from_list]: loop 0:
           Source: 'tests/src/hashmap.rs', lines 199:12-206:17 *)
        fun hashMap_move_elements_from_list_loop
          ('t) (ntable : HashMap_t 't) (ls : AList_t 't) :
          result (HashMap_t 't)
          where
          case ls of
          | AList_Cons k v tl =>
            let ntable1 = hashMap_insert_no_resize ntable k v in
            hashMap_move_elements_from_list_loop ntable1 tl
          | AList_Nil => Ok ntable
        
        (* [hashmap::{hashmap::HashMap<T>}::move_elements_from_list]:
           Source: 'tests/src/hashmap.rs', lines 196:4-209:5 *)
        definition hashMap_move_elements_from_list
          ('t) (ntable : HashMap_t 't) (ls : AList_t 't) :
          result (HashMap_t 't)
          where
          hashMap_move_elements_from_list_loop ntable ls
        
        where
          
          (* [hashmap::{hashmap::HashMap<T>}::move_elements]: loop 0:
             Source: 'tests/src/hashmap.rs', lines 185:8-192:9 *)
          fun hashMap_move_elements_loop
            ('t) (ntable : HashMap_t 't) (slots : alloc_vec_Vec (AList_t 't))
            (i : usize) :
            result ((HashMap_t 't) × (alloc_vec_Vec (AList_t 't)))
            where
            let i1 = alloc_vec_Vec_len slots in
            if usize_lt i i1
            then (
              let (a, index_mut_back) =
                alloc_vec_Vec_index_mut
                  (core_slice_index_SliceIndexUsizeSliceInst (AList_t 't))
                  slots i
              in
              let (ls, a1) = core_mem_replace a AList_Nil in
              let ntable1 = hashMap_move_elements_from_list ntable ls in
              let i2 = usize_add i 1 :: usize in
              let slots1 = index_mut_back a1 in
              hashMap_move_elements_loop ntable1 slots1 i2)
            else Ok (ntable, slots)
          
          (* [hashmap::{hashmap::HashMap<T>}::move_elements]:
             Source: 'tests/src/hashmap.rs', lines 183:4-193:5 *)
          definition hashMap_move_elements
            ('t) (ntable : HashMap_t 't) (slots : alloc_vec_Vec (AList_t 't)) :
            result ((HashMap_t 't) × (alloc_vec_Vec (AList_t 't)))
            where
            hashMap_move_elements_loop ntable slots 0 :: usize
          
          (* [hashmap::{hashmap::HashMap<T>}::try_resize]:
             Source: 'tests/src/hashmap.rs', lines 160:4-179:5 *)
          definition hashMap_try_resize
            ('t) (self : HashMap_t 't) : result (HashMap_t 't) where
            let capacity = alloc_vec_Vec_len slots self in
            let n1 = usize_div core_num_Usize_MAX 2 :: usize in
            let i = usize_div n1 dividend max_load_factor self in
            if usize_le capacity i
            then (
              let i1 = usize_mul capacity 2 :: usize in
              let ntable = hashMap_new_with_capacity 't i1 max_load_factor self
              in
              let (ntable1, _) = hashMap_move_elements ntable slots self in
              Ok
                (|
                  self
                    with
                    max_load := max_load ntable1, slots := slots ntable1
                |))
            else Ok (| self with saturated := True |)
          
          (* [hashmap::{hashmap::HashMap<T>}::insert]:
             Source: 'tests/src/hashmap.rs', lines 149:4-156:5 *)
          definition hashMap_insert
            ('t) (self : HashMap_t 't) (key : usize) (value1 : 't) :
            result (HashMap_t 't)
            where
            let self1 = hashMap_insert_no_resize self key value1 in
            let i = hashMap_len self1 in
            if usize_gt i max_load self1
            then if saturated self1 then Ok self1 else hashMap_try_resize self1
            else Ok self1
          
          where
            
            (* [hashmap::{hashmap::HashMap<T>}::contains_key_in_list]: loop 0:
               Source: 'tests/src/hashmap.rs', lines 1:0-231:9 *)
            fun hashMap_contains_key_in_list_loop
              ('t) (key : usize) (ls : AList_t 't) : result bool where
              case ls of
              | AList_Cons ckey _ tl =>
                if ckey = key
                then Ok True
                else hashMap_contains_key_in_list_loop key tl
              | AList_Nil => Ok False
            
            (* [hashmap::{hashmap::HashMap<T>}::contains_key_in_list]:
               Source: 'tests/src/hashmap.rs', lines 219:4-232:5 *)
            definition hashMap_contains_key_in_list
              ('t) (key : usize) (ls : AList_t 't) : result bool where
              hashMap_contains_key_in_list_loop key ls
            
            (* [hashmap::{hashmap::HashMap<T>}::contains_key]:
               Source: 'tests/src/hashmap.rs', lines 212:4-216:5 *)
            definition hashMap_contains_key
              ('t) (self : HashMap_t 't) (key : usize) : result bool where
              let hash = hash_key key in
              let i = alloc_vec_Vec_len slots self in
              let hash_mod = usize_rem hash i in
              let a =
                alloc_vec_Vec_index (core_slice_index_SliceIndexUsizeSliceInst
                  (AList_t 't)) slots self hash_mod
              in
              hashMap_contains_key_in_list key a
            
            where
              
              (* [hashmap::{hashmap::HashMap<T>}::get_in_list]: loop 0:
                 Source: 'tests/src/hashmap.rs', lines 238:8-246:5 *)
              fun hashMap_get_in_list_loop
                ('t) (key : usize) (ls : AList_t 't) : result (option 't) where
                case ls of
                | AList_Cons ckey cvalue tl =>
                  if ckey = key
                  then Ok (Some cvalue)
                  else hashMap_get_in_list_loop key tl
                | AList_Nil => Ok None
              
              (* [hashmap::{hashmap::HashMap<T>}::get_in_list]:
                 Source: 'tests/src/hashmap.rs', lines 237:4-246:5 *)
              definition hashMap_get_in_list
                ('t) (key : usize) (ls : AList_t 't) : result (option 't) where
                hashMap_get_in_list_loop key ls
              
              (* [hashmap::{hashmap::HashMap<T>}::get]:
                 Source: 'tests/src/hashmap.rs', lines 248:4-252:5 *)
              definition hashMap_get
                ('t) (self : HashMap_t 't) (key : usize) :
                result (option 't)
                where
                let hash = hash_key key in
                let i = alloc_vec_Vec_len slots self in
                let hash_mod = usize_rem hash i in
                let a =
                  alloc_vec_Vec_index
                    (core_slice_index_SliceIndexUsizeSliceInst (AList_t 't))
                    slots self hash_mod
                in
                hashMap_get_in_list key a
              
              where
                
                (* [hashmap::{hashmap::HashMap<T>}::get_mut_in_list]: loop 0:
                   Source: 'tests/src/hashmap.rs', lines 255:8-263:5 *)
                fun hashMap_get_mut_in_list_loop
                  ('t) (ls : AList_t 't) (key : usize) :
                  result ((option 't) × (option 't ⇒ AList_t 't))
                  where
                  case ls of
                  | AList_Cons ckey cvalue tl =>
                    if ckey = key
                    then
                      let back =
                        fun (ret : option 't) =>
                          let t = case ret of | Some t1 => t1 | _ => cvalue in
                          AList_Cons ckey t tl
                      in
                      Ok (Some cvalue, back)
                    else (
                      let (o, back) = hashMap_get_mut_in_list_loop tl key in
                      let back1 =
                        fun (ret : option 't) =>
                          let tl1 = back ret in AList_Cons ckey cvalue tl1
                      in
                      Ok (o, back1))
                  | AList_Nil =>
                    let back = fun (ret : option 't) => AList_Nil in
                    Ok (None, back)
                
                (* [hashmap::{hashmap::HashMap<T>}::get_mut_in_list]:
                   Source: 'tests/src/hashmap.rs', lines 254:4-263:5 *)
                definition hashMap_get_mut_in_list
                  ('t) (ls : AList_t 't) (key : usize) :
                  result ((option 't) × (option 't ⇒ AList_t 't))
                  where
                  hashMap_get_mut_in_list_loop ls key
                
                (* [hashmap::{hashmap::HashMap<T>}::get_mut]:
                   Source: 'tests/src/hashmap.rs', lines 266:4-270:5 *)
                definition hashMap_get_mut
                  ('t) (self : HashMap_t 't) (key : usize) :
                  result ((option 't) × (option 't ⇒ HashMap_t 't))
                  where
                  let hash = hash_key key in
                  let i = alloc_vec_Vec_len slots self in
                  let hash_mod = usize_rem hash i in
                  let (a, index_mut_back) =
                    alloc_vec_Vec_index_mut
                      (core_slice_index_SliceIndexUsizeSliceInst (AList_t 't))
                      slots self hash_mod
                  in
                  let (o, get_mut_in_list_back) = hashMap_get_mut_in_list a key
                  in
                  let back =
                    fun (ret : option 't) =>
                      let a1 = get_mut_in_list_back ret in
                      let v = index_mut_back a1 in
                      (| self with slots := v |)
                  in
                  Ok (o, back)
                
                where
                  
                  (* [hashmap::{hashmap::HashMap<T>}::remove_from_list]: loop 0:
                     Source: 'tests/src/hashmap.rs', lines 1:0-297:17 *)
                  fun hashMap_remove_from_list_loop
                    ('t) (key : usize) (ls : AList_t 't) :
                    result ((option 't) × (AList_t 't))
                    where
                    case ls of
                    | AList_Cons ckey t tl =>
                      if ckey = key
                      then
                        let (mv_ls, _) = core_mem_replace ls AList_Nil in
                        case mv_ls of
                        | AList_Cons _ cvalue tl1 => Ok (Some cvalue, tl1)
                        | AList_Nil => Fail Failure
                      else (
                        let (o, tl1) = hashMap_remove_from_list_loop key tl in
                        Ok (o, AList_Cons ckey t tl1))
                    | AList_Nil => Ok (None, AList_Nil)
                  
                  (* [hashmap::{hashmap::HashMap<T>}::remove_from_list]:
                     Source: 'tests/src/hashmap.rs', lines 274:4-300:5 *)
                  definition hashMap_remove_from_list
                    ('t) (key : usize) (ls : AList_t 't) :
                    result ((option 't) × (AList_t 't))
                    where
                    hashMap_remove_from_list_loop key ls
                  
                  (* [hashmap::{hashmap::HashMap<T>}::remove]:
                     Source: 'tests/src/hashmap.rs', lines 303:4-315:5 *)
                  definition hashMap_remove
                    ('t) (self : HashMap_t 't) (key : usize) :
                    result ((option 't) × (HashMap_t 't))
                    where
                    let hash = hash_key key in
                    let i = alloc_vec_Vec_len slots self in
                    let hash_mod = usize_rem hash i in
                    let (a, index_mut_back) =
                      alloc_vec_Vec_index_mut
                        (core_slice_index_SliceIndexUsizeSliceInst (AList_t
                        't)) slots self hash_mod
                    in
                    let (x, a1) = hashMap_remove_from_list key a in
                    case x of
                    | None =>
                      let v = index_mut_back a1 in
                      Ok (None, (| self with slots := v |))
                    | Some _ =>
                      let i1 = usize_sub num_entries self 1 :: usize in
                      let v = index_mut_back a1 in
                      Ok (x, (| self with num_entries := i1, slots := v |))
                  
                  (* [hashmap::insert_on_disk]:
                     Source: 'tests/src/hashmap.rs', lines 334:0-341:1 *)
                  definition insert_on_disk
                    (key : usize) (value1 : u64) (st : state) :
                    result (state × unit)
                    where
                    let (st1, hm) = utils_deserialize st in
                    let hm1 = hashMap_insert hm key value1 in
                    utils_serialize hm1 st1
                  
end
