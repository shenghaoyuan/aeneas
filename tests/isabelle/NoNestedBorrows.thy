(** THIS FILE WAS AUTOMATICALLY GENERATED BY AENEAS *)
(** [no_nested_borrows] *)

theory NoNestedBorrows
  imports
    Aeneas.Primitives
    begin
\m(* [no_nested_borrows::Pair]
   Source: 'tests/src/no_nested_borrows.rs', lines 6:0-9:1 *)
record Pair_t (''t1') (''t2') = x : 't1
                                y : 't2(* [no_nested_borrows::List]
                                          Source: 'tests/src/no_nested_borrows.rs', lines 11:0-14:1 *)
datatype List_t (''t') =
| List_Cons 't of  List_t 't ⇒ List_t 't
| List_Nil List_t 't(* [no_nested_borrows::One]
                       Source: 'tests/src/no_nested_borrows.rs', lines 22:0-24:1 *)
datatype One_t (''t1') = | One_One 't1 ⇒ One_t 't1(* [no_nested_borrows::EmptyEnum]
                                                       Source: 'tests/src/no_nested_borrows.rs', lines 28:0-30:1 *)
datatype EmptyEnum_t = | EmptyEnum_Empty EmptyEnum_t(* [no_nested_borrows::Enum]
                                                       Source: 'tests/src/no_nested_borrows.rs', lines 34:0-37:1 *)
datatype Enum_t = | Enum_Variant1 Enum_t | Enum_Variant2 Enum_t(* [no_nested_borrows::EmptyStruct]
                                                                  Source: 'tests/src/no_nested_borrows.rs', lines 41:0-41:25 *)
record EmptyStruct_t = 
(* [no_nested_borrows::Sum]
   Source: 'tests/src/no_nested_borrows.rs', lines 43:0-46:1 *)
datatype Sum_t (''t1') (''t2') =
| Sum_Left 't1 ⇒ Sum_t 't1 't2
| Sum_Right 't2 ⇒ Sum_t 't1 't2
(* [no_nested_borrows::cast_u32_to_i32]:
   Source: 'tests/src/no_nested_borrows.rs', lines 48:0-50:1 *)
definition cast_u32_to_i32 (x : u32) : result i32 where
  mk_i32 (u32_to_int x)

(* [no_nested_borrows::cast_bool_to_i32]:
   Source: 'tests/src/no_nested_borrows.rs', lines 52:0-54:1 *)
definition cast_bool_to_i32 (x : bool) : result i32 where
  mk_i32 (bool_to_int x)

(* [no_nested_borrows::cast_bool_to_bool]:
   Source: 'tests/src/no_nested_borrows.rs', lines 57:0-59:1 *)
definition cast_bool_to_bool (x : bool) : result bool where
  Ok x

(* [no_nested_borrows::test2]:
   Source: 'tests/src/no_nested_borrows.rs', lines 62:0-72:1 *)
definition test2 : result unit where
  let _ = u32_add 23 :: u32 44 :: u32 in Ok ()

(* Unit test for [no_nested_borrows::test2] *)
(* Unit test: test2 should evaluate to Ok () *)

(* [no_nested_borrows::get_max]:
   Source: 'tests/src/no_nested_borrows.rs', lines 74:0-80:1 *)
definition get_max (x : u32) (y : u32) : result u32 where
  if u32_ge x y then Ok x else Ok y

(* [no_nested_borrows::test3]:
   Source: 'tests/src/no_nested_borrows.rs', lines 82:0-87:1 *)
definition test3 : result unit where
  let x = get_max 4 :: u32 3 :: u32 in
  let y = get_max 10 :: u32 11 :: u32 in
  let z = u32_add x y in
  massert (z = 15 :: u32)

(* Unit test for [no_nested_borrows::test3] *)
(* Unit test: test3 should evaluate to Ok () *)

(* [no_nested_borrows::test_neg1]:
   Source: 'tests/src/no_nested_borrows.rs', lines 89:0-93:1 *)
definition test_neg1 : result unit where
  let y = i32_neg 3 :: i32 in massert (y = (-3) :: i32)

(* Unit test for [no_nested_borrows::test_neg1] *)
(* Unit test: test_neg1 should evaluate to Ok () *)

(* [no_nested_borrows::refs_test1]:
   Source: 'tests/src/no_nested_borrows.rs', lines 96:0-105:1 *)
definition refs_test1 : result unit where
  massert (1 :: i32 = 1 :: i32)

(* Unit test for [no_nested_borrows::refs_test1] *)
(* Unit test: refs_test1 should evaluate to Ok () *)

(* [no_nested_borrows::refs_test2]:
   Source: 'tests/src/no_nested_borrows.rs', lines 107:0-119:1 *)
definition refs_test2 : result unit where
  let _ = massert (2 :: i32 = 2 :: i32) in
  let _ = massert (0 :: i32 = 0 :: i32) in
  let _ = massert (2 :: i32 = 2 :: i32) in
  massert (2 :: i32 = 2 :: i32)

(* Unit test for [no_nested_borrows::refs_test2] *)
(* Unit test: refs_test2 should evaluate to Ok () *)

(* [no_nested_borrows::test_list1]:
   Source: 'tests/src/no_nested_borrows.rs', lines 123:0-125:1 *)
definition test_list1 : result unit where
  Ok ()

(* Unit test for [no_nested_borrows::test_list1] *)
(* Unit test: test_list1 should evaluate to Ok () *)

(* [no_nested_borrows::copy_int]:
   Source: 'tests/src/no_nested_borrows.rs', lines 127:0-129:1 *)
definition copy_int (x : i32) : result i32 where
  Ok x

(* [no_nested_borrows::test_unreachable]:
   Source: 'tests/src/no_nested_borrows.rs', lines 133:0-137:1 *)
definition test_unreachable (b : bool) : result unit where
  massert b

(* [no_nested_borrows::test_panic]:
   Source: 'tests/src/no_nested_borrows.rs', lines 140:0-144:1 *)
definition test_panic (b : bool) : result unit where
  massert b

(* [no_nested_borrows::test_panic_msg]:
   Source: 'tests/src/no_nested_borrows.rs', lines 148:0-152:1 *)
definition test_panic_msg (b : bool) : result unit where
  massert b

(* [no_nested_borrows::test_copy_int]:
   Source: 'tests/src/no_nested_borrows.rs', lines 155:0-160:1 *)
definition test_copy_int : result unit where
  let y = copy_int 0 :: i32 in massert (0 :: i32 = y)

(* Unit test for [no_nested_borrows::test_copy_int] *)
(* Unit test: test_copy_int should evaluate to Ok () *)

(* [no_nested_borrows::is_cons]:
   Source: 'tests/src/no_nested_borrows.rs', lines 162:0-167:1 *)
definition is_cons ('t) (l : List_t 't) : result bool where
  case l of | List_Cons _ _ => Ok True | List_Nil => Ok False

(* [no_nested_borrows::test_is_cons]:
   Source: 'tests/src/no_nested_borrows.rs', lines 169:0-173:1 *)
definition test_is_cons : result unit where
  let b = is_cons (List_Cons 0 :: i32 List_Nil) in massert b

(* Unit test for [no_nested_borrows::test_is_cons] *)
(* Unit test: test_is_cons should evaluate to Ok () *)

(* [no_nested_borrows::split_list]:
   Source: 'tests/src/no_nested_borrows.rs', lines 175:0-180:1 *)
definition split_list ('t) (l : List_t 't) : result ('t × (List_t 't)) where
  case l of | List_Cons hd tl => Ok (hd, tl) | List_Nil => Fail Failure

(* [no_nested_borrows::test_split_list]:
   Source: 'tests/src/no_nested_borrows.rs', lines 183:0-188:1 *)
definition test_split_list : result unit where
  let (hd, _) = split_list (List_Cons 0 :: i32 List_Nil) in
  massert (hd = 0 :: i32)

(* Unit test for [no_nested_borrows::test_split_list] *)
(* Unit test: test_split_list should evaluate to Ok () *)

(* [no_nested_borrows::choose]:
   Source: 'tests/src/no_nested_borrows.rs', lines 190:0-196:1 *)
definition choose
  ('t) (b : bool) (x : 't) (y : 't) : result ('t × ('t ⇒ ('t × 't))) where
  if b
  then let back = fun (ret : 't) => (ret, y) in Ok (x, back)
  else let back = fun (ret : 't) => (x, ret) in Ok (y, back)

(* [no_nested_borrows::choose_test]:
   Source: 'tests/src/no_nested_borrows.rs', lines 198:0-207:1 *)
definition choose_test : result unit where
  let (z, choose_back) = choose True 0 :: i32 0 :: i32 in
  let z1 = i32_add z 1 :: i32 in
  let _ = massert (z1 = 1 :: i32) in
  let (x, y) = choose_back z1 in
  let _ = massert (x = 1 :: i32) in
  massert (y = 0 :: i32)

(* Unit test for [no_nested_borrows::choose_test] *)
(* Unit test: choose_test should evaluate to Ok () *)

(* [no_nested_borrows::test_char]:
   Source: 'tests/src/no_nested_borrows.rs', lines 210:0-212:1 *)
definition test_char : result char where
  Ok (CHR ''97'')

(* [no_nested_borrows::panic_mut_borrow]:
   Source: 'tests/src/no_nested_borrows.rs', lines 215:0-217:1 *)
definition panic_mut_borrow (i : u32) : result u32 where
  Fail Failure

datatype
  (* [no_nested_borrows::Tree]
     Source: 'tests/src/no_nested_borrows.rs', lines 220:0-223:1 *)
  datatype Tree_t (''t') =
  | Tree_Leaf 't ⇒ Tree_t 't
  | Tree_Node 't of  NodeElem_t 't of  Tree_t 't ⇒ Tree_t 't
  
  (* [no_nested_borrows::NodeElem]
     Source: 'tests/src/no_nested_borrows.rs', lines 225:0-228:1 *)
  and NodeElem_t (''t') =
  | NodeElem_Cons Tree_t 't of  NodeElem_t 't ⇒ NodeElem_t 't
  | NodeElem_Nil NodeElem_t 't

where
  
  (* [no_nested_borrows::list_length]:
     Source: 'tests/src/no_nested_borrows.rs', lines 260:0-265:1 *)
  fun list_length ('t) (l : List_t 't) : result u32 where
    case l of
    | List_Cons _ l1 => let i = list_length l1 in u32_add 1 :: u32 i
    | List_Nil => Ok 0 :: u32
  
  where
    
    (* [no_nested_borrows::list_nth_shared]:
       Source: 'tests/src/no_nested_borrows.rs', lines 268:0-281:1 *)
    fun list_nth_shared ('t) (l : List_t 't) (i : u32) : result 't where
      case l of
      | List_Cons x tl =>
        if i = 0 :: u32
        then Ok x
        else (let i1 = u32_sub i 1 :: u32 in list_nth_shared tl i1)
      | List_Nil => Fail Failure
    
    where
      
      (* [no_nested_borrows::list_nth_mut]:
         Source: 'tests/src/no_nested_borrows.rs', lines 284:0-297:1 *)
      fun list_nth_mut
        ('t) (l : List_t 't) (i : u32) :
        result ('t × ('t ⇒ List_t 't))
        where
        case l of
        | List_Cons x tl =>
          if i = 0 :: u32
          then let back = fun (ret : 't) => List_Cons ret tl in Ok (x, back)
          else (
            let i1 = u32_sub i 1 :: u32 in
            let (x1, list_nth_mut_back) = list_nth_mut tl i1 in
            let back =
              fun (ret : 't) =>
                let tl1 = list_nth_mut_back ret in List_Cons x tl1
            in
            Ok (x1, back))
        | List_Nil => Fail Failure
      
      where
        
        (* [no_nested_borrows::list_rev_aux]:
           Source: 'tests/src/no_nested_borrows.rs', lines 300:0-310:1 *)
        fun list_rev_aux
          ('t) (li : List_t 't) (lo : List_t 't) : result (List_t 't) where
          case li of
          | List_Cons hd tl => list_rev_aux tl (List_Cons hd lo)
          | List_Nil => Ok lo
        
        (* [no_nested_borrows::list_rev]:
           Source: 'tests/src/no_nested_borrows.rs', lines 314:0-317:1 *)
        definition list_rev ('t) (l : List_t 't) : result (List_t 't) where
          let (li, _) = core_mem_replace l List_Nil in list_rev_aux li List_Nil
        
        (* [no_nested_borrows::test_list_functions]:
           Source: 'tests/src/no_nested_borrows.rs', lines 319:0-333:1 *)
        definition test_list_functions : result unit where
          let l = List_Cons 2 :: i32 List_Nil in
          let l1 = List_Cons 1 :: i32 l in
          let i = list_length (List_Cons 0 :: i32 l1) in
          let _ = massert (i = 3 :: u32) in
          let i1 = list_nth_shared (List_Cons 0 :: i32 l1) 0 :: u32 in
          let _ = massert (i1 = 0 :: i32) in
          let i2 = list_nth_shared (List_Cons 0 :: i32 l1) 1 :: u32 in
          let _ = massert (i2 = 1 :: i32) in
          let i3 = list_nth_shared (List_Cons 0 :: i32 l1) 2 :: u32 in
          let _ = massert (i3 = 2 :: i32) in
          let (_, list_nth_mut_back) =
            list_nth_mut (List_Cons 0 :: i32 l1) 1 :: u32
          in
          let ls = list_nth_mut_back 3 :: i32 in
          let i4 = list_nth_shared ls 0 :: u32 in
          let _ = massert (i4 = 0 :: i32) in
          let i5 = list_nth_shared ls 1 :: u32 in
          let _ = massert (i5 = 3 :: i32) in
          let i6 = list_nth_shared ls 2 :: u32 in
          massert (i6 = 2 :: i32)
        
        (* Unit test for [no_nested_borrows::test_list_functions] *)
        (* Unit test: test_list_functions should evaluate to Ok () *)
        
        (* [no_nested_borrows::id_mut_pair1]:
           Source: 'tests/src/no_nested_borrows.rs', lines 335:0-337:1 *)
        definition id_mut_pair1
          ('t1) ('t2) (x : 't1) (y : 't2) :
          result (('t1 × 't2) × (('t1 × 't2) ⇒ ('t1 × 't2)))
          where
          Ok ((x, y), fun (ret : ('t1 × 't2)) => ret)
        
        (* [no_nested_borrows::id_mut_pair2]:
           Source: 'tests/src/no_nested_borrows.rs', lines 339:0-341:1 *)
        definition id_mut_pair2
          ('t1) ('t2) (p : ('t1 × 't2)) :
          result (('t1 × 't2) × (('t1 × 't2) ⇒ ('t1 × 't2)))
          where
          Ok (p, fun (ret : ('t1 × 't2)) => ret)
        
        (* [no_nested_borrows::id_mut_pair3]:
           Source: 'tests/src/no_nested_borrows.rs', lines 343:0-345:1 *)
        definition id_mut_pair3
          ('t1) ('t2) (x : 't1) (y : 't2) :
          result (('t1 × 't2) × ('t1 ⇒ 't1) × ('t2 ⇒ 't2))
          where
          Ok ((x, y), fun (ret : 't1) => ret, fun (ret : 't2) => ret)
        
        (* [no_nested_borrows::id_mut_pair4]:
           Source: 'tests/src/no_nested_borrows.rs', lines 347:0-349:1 *)
        definition id_mut_pair4
          ('t1) ('t2) (p : ('t1 × 't2)) :
          result (('t1 × 't2) × ('t1 ⇒ 't1) × ('t2 ⇒ 't2))
          where
          Ok (p, fun (ret : 't1) => ret, fun (ret : 't2) => ret)
        (* [no_nested_borrows::StructWithTuple]
           Source: 'tests/src/no_nested_borrows.rs', lines 354:0-356:1 *)
        record StructWithTuple_t (''t1') (''t2') = p : ('t1 × 't2)
        (* [no_nested_borrows::new_tuple1]:
           Source: 'tests/src/no_nested_borrows.rs', lines 358:0-360:1 *)
        definition new_tuple1 : result (StructWithTuple_t u32 u32) where
          Ok (| p = (1 :: u32, 2 :: u32) |)
        
        (* [no_nested_borrows::new_tuple2]:
           Source: 'tests/src/no_nested_borrows.rs', lines 362:0-364:1 *)
        definition new_tuple2 : result (StructWithTuple_t i16 i16) where
          Ok (| p = (1 :: i16, 2 :: i16) |)
        
        (* [no_nested_borrows::new_tuple3]:
           Source: 'tests/src/no_nested_borrows.rs', lines 366:0-368:1 *)
        definition new_tuple3 : result (StructWithTuple_t u64 i64) where
          Ok (| p = (1 :: u64, 2 :: i64) |)
        (* [no_nested_borrows::StructWithPair]
           Source: 'tests/src/no_nested_borrows.rs', lines 371:0-373:1 *)
        record StructWithPair_t (''t1') (''t2') = p : Pair_t 't1 't2
        (* [no_nested_borrows::new_pair1]:
           Source: 'tests/src/no_nested_borrows.rs', lines 375:0-381:1 *)
        definition new_pair1 : result (StructWithPair_t u32 u32) where
          Ok (| p = (| x = 1 :: u32, y = 2 :: u32 |) |)
        
        (* [no_nested_borrows::test_constants]:
           Source: 'tests/src/no_nested_borrows.rs', lines 383:0-388:1 *)
        definition test_constants : result unit where
          let swt = new_tuple1 in
          let (i, _) = p swt in
          let _ = massert (i = 1 :: u32) in
          let swt1 = new_tuple2 in
          let (i1, _) = p swt1 in
          let _ = massert (i1 = 1 :: i16) in
          let swt2 = new_tuple3 in
          let (i2, _) = p swt2 in
          let _ = massert (i2 = 1 :: u64) in
          let swp = new_pair1 in
          massert (x p swp = 1 :: u32)
        
        (* Unit test for [no_nested_borrows::test_constants] *)
        (* Unit test: test_constants should evaluate to Ok () *)
        
        (* [no_nested_borrows::test_weird_borrows1]:
           Source: 'tests/src/no_nested_borrows.rs', lines 392:0-400:1 *)
        definition test_weird_borrows1 : result unit where
          Ok ()
        
        (* Unit test for [no_nested_borrows::test_weird_borrows1] *)
        (* Unit test: test_weird_borrows1 should evaluate to Ok () *)
        
        (* [no_nested_borrows::test_mem_replace]:
           Source: 'tests/src/no_nested_borrows.rs', lines 402:0-406:1 *)
        definition test_mem_replace (px : u32) : result u32 where
          let (y, _) = core_mem_replace px 1 :: u32 in
          let _ = massert (y = 0 :: u32) in
          Ok 2 :: u32
        
        (* [no_nested_borrows::test_shared_borrow_bool1]:
           Source: 'tests/src/no_nested_borrows.rs', lines 409:0-418:1 *)
        definition test_shared_borrow_bool1 (b : bool) : result u32 where
          if b then Ok 0 :: u32 else Ok 1 :: u32
        
        (* [no_nested_borrows::test_shared_borrow_bool2]:
           Source: 'tests/src/no_nested_borrows.rs', lines 422:0-432:1 *)
        definition test_shared_borrow_bool2 : result u32 where
          Ok 0 :: u32
        
        (* [no_nested_borrows::test_shared_borrow_enum1]:
           Source: 'tests/src/no_nested_borrows.rs', lines 437:0-445:1 *)
        definition test_shared_borrow_enum1 (l : List_t u32) : result u32 where
          case l of | List_Cons _ _ => Ok 1 :: u32 | List_Nil => Ok 0 :: u32
        
        (* [no_nested_borrows::test_shared_borrow_enum2]:
           Source: 'tests/src/no_nested_borrows.rs', lines 449:0-458:1 *)
        definition test_shared_borrow_enum2 : result u32 where
          Ok 0 :: u32
        
        (* [no_nested_borrows::incr]:
           Source: 'tests/src/no_nested_borrows.rs', lines 460:0-462:1 *)
        definition incr (x : u32) : result u32 where
          u32_add x 1 :: u32
        
        (* [no_nested_borrows::call_incr]:
           Source: 'tests/src/no_nested_borrows.rs', lines 464:0-467:1 *)
        definition call_incr (x : u32) : result u32 where
          incr x
        
        (* [no_nested_borrows::read_then_incr]:
           Source: 'tests/src/no_nested_borrows.rs', lines 469:0-473:1 *)
        definition read_then_incr (x : u32) : result (u32 × u32) where
          let x1 = u32_add x 1 :: u32 in Ok (x, x1)
        (* [no_nested_borrows::Tuple]
           Source: 'tests/src/no_nested_borrows.rs', lines 475:0-475:33 *)
        abbreviation Tuple_t (''t1') (''t2') = 't1 × 't2
        (* [no_nested_borrows::read_tuple]:
           Source: 'tests/src/no_nested_borrows.rs', lines 477:0-479:1 *)
        definition read_tuple (x : (u32 × u32)) : result u32 where
          let (i, _) = x in Ok i
        
        (* [no_nested_borrows::update_tuple]:
           Source: 'tests/src/no_nested_borrows.rs', lines 481:0-483:1 *)
        definition update_tuple (x : (u32 × u32)) : result (u32 × u32) where
          let (_, i) = x in Ok (1 :: u32, i)
        
        (* [no_nested_borrows::read_tuple_struct]:
           Source: 'tests/src/no_nested_borrows.rs', lines 485:0-487:1 *)
        definition read_tuple_struct (x : Tuple_t u32 u32) : result u32 where
          let (i, _) = x in Ok i
        
        (* [no_nested_borrows::update_tuple_struct]:
           Source: 'tests/src/no_nested_borrows.rs', lines 489:0-491:1 *)
        definition update_tuple_struct
          (x : Tuple_t u32 u32) : result (Tuple_t u32 u32) where
          let (_, i) = x in Ok (1 :: u32, i)
        
        (* [no_nested_borrows::create_tuple_struct]:
           Source: 'tests/src/no_nested_borrows.rs', lines 493:0-495:1 *)
        definition create_tuple_struct
          (x : u32) (y : u64) : result (Tuple_t u32 u64) where
          Ok (x, y)
        (* [no_nested_borrows::IdType]
           Source: 'tests/src/no_nested_borrows.rs', lines 498:0-498:24 *)
        abbreviation IdType_t (''t') = 't
        (* [no_nested_borrows::use_id_type]:
           Source: 'tests/src/no_nested_borrows.rs', lines 500:0-502:1 *)
        definition use_id_type ('t) (x : IdType_t 't) : result 't where
          Ok x
        
        (* [no_nested_borrows::create_id_type]:
           Source: 'tests/src/no_nested_borrows.rs', lines 504:0-506:1 *)
        definition create_id_type ('t) (x : 't) : result (IdType_t 't) where
          Ok x
        
        (* [no_nested_borrows::not_bool]:
           Source: 'tests/src/no_nested_borrows.rs', lines 508:0-510:1 *)
        definition not_bool (x : bool) : result bool where
          Ok (~ x)
        
        (* [no_nested_borrows::not_u32]:
           Source: 'tests/src/no_nested_borrows.rs', lines 512:0-514:1 *)
        definition not_u32 (x : u32) : result u32 where
          Ok (~ x)
        
        (* [no_nested_borrows::not_i32]:
           Source: 'tests/src/no_nested_borrows.rs', lines 516:0-518:1 *)
        definition not_i32 (x : i32) : result i32 where
          Ok (~ x)
        
        (* [no_nested_borrows::borrow_mut_tuple]:
           Source: 'tests/src/no_nested_borrows.rs', lines 520:0-522:1 *)
        definition borrow_mut_tuple
          ('t) ('u) (x : ('t × 'u)) :
          result (('t × 'u) × (('t × 'u) ⇒ ('t × 'u)))
          where
          Ok (x, fun (ret : ('t × 'u)) => ret)
        (* [no_nested_borrows::ExpandSimpliy::Wrapper]
           Source: 'tests/src/no_nested_borrows.rs', lines 526:4-526:32 *)
        abbreviation ExpandSimpliy_Wrapper_t (''t') = 't × 't
        (* [no_nested_borrows::ExpandSimpliy::check_expand_simplify_symb1]:
           Source: 'tests/src/no_nested_borrows.rs', lines 528:4-534:5 *)
        definition expandSimpliy_check_expand_simplify_symb1
          (x : ExpandSimpliy_Wrapper_t bool) :
          result (ExpandSimpliy_Wrapper_t bool)
          where
          let (b, _) = x in if b then Ok x else Ok x
        (* [no_nested_borrows::ExpandSimpliy::Wrapper2]
           Source: 'tests/src/no_nested_borrows.rs', lines 536:4-539:5 *)
        record ExpandSimpliy_Wrapper2_t = b : bool
                                          x : u32
        (* [no_nested_borrows::ExpandSimpliy::check_expand_simplify_symb2]:
           Source: 'tests/src/no_nested_borrows.rs', lines 541:4-547:5 *)
        definition expandSimpliy_check_expand_simplify_symb2
          (x : ExpandSimpliy_Wrapper2_t) :
          result ExpandSimpliy_Wrapper2_t
          where
          if b x then Ok x else Ok x
        
end
