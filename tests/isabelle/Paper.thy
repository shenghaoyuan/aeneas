(** THIS FILE WAS AUTOMATICALLY GENERATED BY AENEAS *)
(** [paper] *)

theory Paper
  imports
    Aeneas.Primitives
    begin
\m
(* [paper::ref_incr]:
   Source: 'tests/src/paper.rs', lines 6:0-8:1 *)
definition ref_incr (x : i32) : result i32 where
  i32_add x 1 :: i32

(* [paper::test_incr]:
   Source: 'tests/src/paper.rs', lines 10:0-14:1 *)
definition test_incr : result unit where
  let x = ref_incr 0 :: i32 in massert (x = 1 :: i32)

(* Unit test for [paper::test_incr] *)
(* Unit test: test_incr should evaluate to Ok () *)

(* [paper::choose]:
   Source: 'tests/src/paper.rs', lines 17:0-23:1 *)
definition choose
  ('t) (b : bool) (x : 't) (y : 't) : result ('t × ('t ⇒ ('t × 't))) where
  if b
  then let back = fun (ret : 't) => (ret, y) in Ok (x, back)
  else let back = fun (ret : 't) => (x, ret) in Ok (y, back)

(* [paper::test_choose]:
   Source: 'tests/src/paper.rs', lines 25:0-33:1 *)
definition test_choose : result unit where
  let (z, choose_back) = choose True 0 :: i32 0 :: i32 in
  let z1 = i32_add z 1 :: i32 in
  let _ = massert (z1 = 1 :: i32) in
  let (x, y) = choose_back z1 in
  let _ = massert (x = 1 :: i32) in
  massert (y = 0 :: i32)

(* Unit test for [paper::test_choose] *)
(* Unit test: test_choose should evaluate to Ok () *)
(* [paper::List]
   Source: 'tests/src/paper.rs', lines 37:0-40:1 *)
datatype List_t (''t') =
| List_Cons 't of  List_t 't ⇒ List_t 't
| List_Nil List_t 't
where
  
  (* [paper::list_nth_mut]:
     Source: 'tests/src/paper.rs', lines 44:0-57:1 *)
  fun list_nth_mut
    ('t) (l : List_t 't) (i : u32) : result ('t × ('t ⇒ List_t 't)) where
    case l of
    | List_Cons x tl =>
      if i = 0 :: u32
      then let back = fun (ret : 't) => List_Cons ret tl in Ok (x, back)
      else (
        let i1 = u32_sub i 1 :: u32 in
        let (x1, list_nth_mut_back) = list_nth_mut tl i1 in
        let back =
          fun (ret : 't) => let tl1 = list_nth_mut_back ret in List_Cons x tl1
        in
        Ok (x1, back))
    | List_Nil => Fail Failure
  
  where
    
    (* [paper::sum]:
       Source: 'tests/src/paper.rs', lines 59:0-68:1 *)
    fun sum (l : List_t i32) : result i32 where
      case l of
      | List_Cons x tl => let i = sum tl in i32_add x i
      | List_Nil => Ok 0 :: i32
    
    (* [paper::test_nth]:
       Source: 'tests/src/paper.rs', lines 70:0-75:1 *)
    definition test_nth : result unit where
      let l = List_Cons 3 :: i32 List_Nil in
      let l1 = List_Cons 2 :: i32 l in
      let (x, list_nth_mut_back) =
        list_nth_mut (List_Cons 1 :: i32 l1) 2 :: u32
      in
      let x1 = i32_add x 1 :: i32 in
      let l2 = list_nth_mut_back x1 in
      let i = sum l2 in
      massert (i = 7 :: i32)
    
    (* Unit test for [paper::test_nth] *)
    (* Unit test: test_nth should evaluate to Ok () *)
    
    (* [paper::call_choose]:
       Source: 'tests/src/paper.rs', lines 78:0-84:1 *)
    definition call_choose (p : (u32 × u32)) : result u32 where
      let (px, py) = p in
      let (pz, choose_back) = choose True px py in
      let pz1 = u32_add pz 1 :: u32 in
      let (px1, _) = choose_back pz1 in
      Ok px1
    
end
